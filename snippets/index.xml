<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Snippets on Rohit Goswami</title><link>/snippets/</link><description>Recent content in Snippets on Rohit Goswami</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&lt;a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0&lt;/a>.</copyright><lastBuildDate>Wed, 22 Mar 2023 13:59:00 +0000</lastBuildDate><atom:link href="/snippets/index.xml" rel="self" type="application/rss+xml"/><item><title>Auto-discovering meson tests</title><link>/snippets/auto-disc-meson-tests/</link><pubDate>Wed, 22 Mar 2023 13:59:00 +0000</pubDate><guid>/snippets/auto-disc-meson-tests/</guid><description>One of the things I missed when I migrated from cmake to meson was the ease at which cmake discovers tests.
1# Tests 2option(PACKAGE_TESTS &amp;#34;Build the tests&amp;#34; OFF) 3if(PACKAGE_TESTS) 4 find_package(GTest REQUIRED) 5 enable_testing() 6 include(GoogleTest) 7 add_subdirectory(gtests) 8endif() Thankfully, meson can kind of emulate this behavior, even in its restricted syntax. The key concept is arrays and their iterators.
1test_array = [# 2 # [&amp;#39;Pretty name&amp;#39;, &amp;#39;binary_name&amp;#39;, &amp;#39;BlahTest.cpp&amp;#39;] 3 [&amp;#39;String parser helpers&amp;#39;, &amp;#39;strparse_run&amp;#39;, &amp;#39;StringHelpersTest.</description></item><item><title>Mach-Nix and Shell Environments</title><link>/snippets/mach-nix-shell-env/</link><pubDate>Mon, 17 Jan 2022 02:28:00 +0000</pubDate><guid>/snippets/mach-nix-shell-env/</guid><description>I often need to set up quick virtual environments. Unfortunately, the standard approach to work with this in nix deals with the local nixpkgs mechanism for python dependencies:
1nix-shell -p &amp;#34;python38.withPackages(ps: [ ps.numpy ps.sh ])&amp;#34; However there is a catch for packages which are not officially present upstream.
1# Fails! 2nix-shell -p &amp;#34;python38.withPackages(ps: [ ps.numpy ps.sh ps.lieer ])&amp;#34; However, the mach-nix project can indeed be used to work around this, at the cost of a somewhat longer command.</description></item><item><title>Docker Development Environments</title><link>/snippets/docker-dev-envs/</link><pubDate>Wed, 24 Nov 2021 16:20:00 +0000</pubDate><guid>/snippets/docker-dev-envs/</guid><description>Very quick set of ugly commands to grab build environments. A much better approach is to make a custom Dockerfile or even better, use nix.
However it does work in a pinch.
1docker pull IMG:TAG 2sudo docker run -v LOCALDIR:DIRINDOCKER -it debian:experimental-20211115 bash 3# Don&amp;#39;t be root for long 4apt update 5apt install sudo vim zsh 6# Use the same username --&amp;gt; easier to manage permissions 7useradd -m -s /bin/zsh $USER -G sudo 8passwd $USER # Some crap 9# Or just add to the sudoers file 10echo &amp;#34;$USER ALL=(ALL:ALL) ALL&amp;#34; &amp;gt;&amp;gt; /etc/sudoers 11su $USER 12# numpy stuff 13sudo apt install gcc gfortran libopenblas-dev python3.</description></item><item><title>SSH Port Forwarding</title><link>/snippets/ssh-port-forwarding/</link><pubDate>Wed, 24 Nov 2021 16:20:00 +0000</pubDate><guid>/snippets/ssh-port-forwarding/</guid><description>Whenever I need to access a server running on an HPC which does not support ngrok or localtunnel or even gsocket; the fallback approach is always to rely on SSH port forwarding.
The sample problem here is running an HTTP server for viewing graphics in R via httpgd.
1# Local 2export PORT=9899 &amp;amp;&amp;amp; ssh -L &amp;#34;${PORT}:localhost:${PORT}&amp;#34; &amp;#34;rog32@krafla.rhi.hi.is&amp;#34; -N -L &amp;#34;${PORT}:localhost:${PORT}&amp;#34; elja 3# New tab 4ssh krafla 5ssh elja 6radian # or R Now in R.</description></item><item><title>Programming Language Management</title><link>/snippets/prog-lang-man/</link><pubDate>Sun, 19 Sep 2021 17:39:00 +0000</pubDate><guid>/snippets/prog-lang-man/</guid><description>nix aside1, I recently shifted to using asdf to manage different language versions.
1git clone https://github.com/asdf-vm/asdf.git ~/.asdf --branch v0.8.1 The main reason to prefer asdf over competing language specific options like rvm or pyenv or nvm and company is simply uniformity of the interface. This can be coupled with zinit snippet OMZ::plugins/asdf for loading the completions. Note that the installation steps can take a while especially if openssl is being installed.</description></item><item><title>Watching Files</title><link>/snippets/watch-files/</link><pubDate>Sun, 19 Sep 2021 17:39:00 +0000</pubDate><guid>/snippets/watch-files/</guid><description>My personal favorite for watching files and running context sensitive commands is to use the lovely filewatcher CLI utility written in Ruby.
1gem install filewatcher 2gem install filewatcher-cli This can then be used with:
1filewatcher &amp;#39;**/*.js&amp;#39; &amp;#39;node $FILENAME&amp;#39; However this hasn&amp;rsquo;t been updated in a while now and fails on newer versions of Ruby. So now I use watchexec.
1cargo install watchexec-cli 2watchexec -w source/f2py &amp;#39;make html&amp;#39;</description></item><item><title>Forwarding Multiple Local Ports</title><link>/snippets/forward-multiport/</link><pubDate>Sun, 16 May 2021 03:47:00 +0000</pubDate><guid>/snippets/forward-multiport/</guid><description>Most often it makes more sense to map the same ports on every intermediate machine.
1Host super 2 Hostname super.machine.location.is 3 IdentityFile ~/.ssh/mykey 4 User myuser 5 LocalForward 8001 localhost:8001 6 LocalForward 8002 localhost:8002 7 LocalForward 8003 localhost:8003 8 LocalForward 8004 localhost:8004 This is good for interactive sessions with multiple servers. For single servers, reverse proxy tunnels are more efficient.</description></item><item><title>Overwriting Attributes</title><link>/snippets/nix-collection-overwrite-attrs/</link><pubDate>Sun, 16 May 2021 03:47:00 +0000</pubDate><guid>/snippets/nix-collection-overwrite-attrs/</guid><description> 1doxygen191 = pkgs.doxygen.overrideAttrs (_: rec { 2name = &amp;#34;doxygen-1.9.1&amp;#34;; 3src = pkgs.fetchurl { 4 urls = [ 5 &amp;#34;mirror://sourceforge/doxygen/${name}.src.tar.gz&amp;#34; # faster, with https, etc. 6 &amp;#34;http://doxygen.nl/files/${name}.src.tar.gz&amp;#34; 7 ]; 8 sha256 = &amp;#34;1lcif1qi20gf04qyjrx7x367669g17vz2ilgi4cmamp1whdsxbk7&amp;#34;; 9}; 10});</description></item></channel></rss>