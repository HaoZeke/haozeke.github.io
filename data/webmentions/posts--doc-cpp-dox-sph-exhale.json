[
  {
    "type": "entry",
    "author": {
      "type": "card",
      "name": "Rohit Goswami",
      "photo": "",
      "url": ""
    },
    "url": "https://rgoswami.me/posts/pub-doc-cpp-dox-sph-nix/",
    "published": null,
    "wm-received": "2020-12-29T01:07:02Z",
    "wm-id": 967388,
    "wm-source": "https://rgoswami.me/posts/pub-doc-cpp-dox-sph-nix/",
    "wm-target": "https://rgoswami.me/posts/doc-cpp-dox-sph-exhale/",
    "name": "Publishing Doxygen and Sphinx with Nix and Rake",
    "content": {
      "html": "<blockquote><p>Automating documenation deployment with Travis, <code>rake</code> and <code>nix</code></p></blockquote><h2>Background</h2><p>In <a href=\"https://rgoswami.me/posts/doc-cpp-dox-sph-exhale/\">the previous post</a> we generated documentation using Doxygen with Exhale to handle Sphinx. Now we will clean up the earlier workflow with <code>rake</code> and ensure the environment is reproducible with <code>nix</code> while deploying to <a href=\"https://travis-ci.com/\">Travis CI</a>.</p><h3>Series</h3><ol><li><a href=\"https://rgoswami.me/posts/doc-cpp-dox-sph-exhale/\">Documenting C++ with Doxygen and Sphinx - Exhale</a></li>\n<li>\n<strong>Publishing Doxygen and Sphinx with Nix and Rake</strong> &lt;– You are here</li>\n<li>Documenting C++ with Doxygen and Sphinx - doxyrest</li>\n<li>Adding Tutorials to Sphinx Projects</li>\n</ol><h2>Setup</h2><p>A quick reminder of the setup we generated in the last post:</p><pre><code>tree -d <span>$prj</span>/ -L <span>2</span>\n</code></pre>.\n\n\n├──\ndocs\n\n│  \n├──\nDoxygen\n│  \n└──\nSphinx\n├──\nnix\n\n│  \n└──\npkgs\n├──\nprojects\n\n│  \n└──\nsymengine\n└──\nscripts\n\n\n\n\n8\ndirectories\n\n<p>We had further setup files to enable documentation generation with a manual two stage process (handling <code>doxygen</code> and <code>sphinx</code> separately).</p><pre><code><span>cd</span> docs/Doxygen\ndoxygen Doxyfile-prj.cfg\n<span>cd</span> ../Sphinx\nmake html\nmv build/html ../../public\n</code></pre><p>This might be extracted into a simple <code>build.sh</code> script, and then we might decide to have a <code>clean.sh</code> script and then we might try to replicate all the functionality of a good build system with scripts.</p><p>Thankfully, we will instead start with a <code>build</code> script defined as above to transition to <code>nix</code>, before using an actual build tool for our dirty work.</p><h2>Adding Nix</h2><p>It wouldn’t make sense for me to not stick <code>nix</code> into this. I recall the dark days of setting up <code>Dockerfiles</code> to ensure reproducible environments on Travis.</p><p>At this point one might assume we will leverage the <code>requirements.txt</code> based workflow described earlier in <a href=\"https://rgoswami.me/posts/mach-nix-niv-python/\">Niv and Mach-Nix for Nix Python</a>. While this would make sense, there are two barriers to its usage:</p><ul><li>It is slower than a <code>poetry</code> build, as dependency resolution is performed</li>\n<li>It does not play well with existing projects<ul><li>Most <code>python</code> projects do not rely solely on <code>requirements.txt</code> <a href=\"https://rgoswami.me/posts/pub-doc-cpp-dox-sph-nix/#fn:1\">1</a></li></ul></li>\n</ul><h3>Poetry2Nix</h3><p>Recall that as <code>sphinx</code> is originally meant for and most often used for Python projects, we will need to consider the possibility (remote though it is) that there might be users who would like to test the documentation without setting up <code>nix</code>.</p><p>Thus we will look to the <a href=\"https://github.com/nix-community/poetry2nix#mkPoetryEnv\">poetry2nix project instead</a>. We note the following:</p><ul><li>The <code>poetry2nix</code> setup is faster (as it consumes a <code>lockfile</code> instead of solving dependencies from <code>requirements.txt</code>)<ul><li>\n<code>mach-nix</code> however, is more flexible and can make use of the <code>poetry2nix</code> overrides</li></ul></li>\n<li>In a strange chicken and egg problem, we will have to manually generate the lockfile, thereby creating an impure <code>poetry</code> project for every update, though the <code>nix</code> setup will not need it later<ul><li>This is one of the major reasons to prefer <code>mach-nix</code> for newer projects</li></ul></li>\n</ul><h3>Shell Environment</h3><p>We prep our sources in the usual way, by running <code>niv init</code> in the project root to generate the <code>nix/</code> folder and the sources therein. With all that in mind, the <code>shell.nix</code> file at this point is fairly standard, keeping the general <code>niv</code> setup in mind (described in a <a href=\"https://rgoswami.me/posts/ccon-tut-nix/\">previous Nix tutorial</a>):</p><pre><code><span># -*- mode: nix-mode -*-</span>\n<span>let</span>\n  <span>sources</span> <span>=</span> <span>import</span> <span>./nix/sources.nix</span><span>;</span>\n  <span>pkgs</span> <span>=</span> <span>import</span> <span>sources</span><span>.</span><span>nixpkgs</span> <span>{</span> <span>};</span>\n  <span>customPython</span> <span>=</span> <span>pkgs</span><span>.</span><span>poetry2nix</span><span>.</span><span>mkPoetryEnv</span> <span>{</span> <span>projectDir</span> <span>=</span> <span>./.</span><span>;</span> <span>};</span>\n<span>in</span> <span>pkgs</span><span>.</span><span>mkShell</span> <span>{</span>\n  <span>buildInputs</span> <span>=</span> <span>with</span> <span>pkgs</span><span>;</span> <span>[</span> <span>doxygen</span> <span>customPython</span> <span>rake</span> <span>darkhttpd</span> <span>];</span>\n<span>}</span>\n</code></pre><p>Where the most interesting aspect is that the <code>projectDir</code> is to be the location of the project root, though both <code>poetrylock</code> and <code>pyproject</code> variables are supported.</p><h2>Refactoring</h2><p>We consider the problem of refactoring the <code>build.sh</code> script:</p><pre><code><span>#!/usr/bin/env bash\n</span><span></span><span>cd</span> docs/Doxygen\ndoxygen Doxyfile-prj.cfg\n<span>cd</span> ../Sphinx\nmake html\nmv build/html ../../public\n</code></pre><p>Without resorting to methods such as <code>nix-shell --run build.sh --pure</code>.</p><h3>Nix Bash</h3><p>Script in hand, we would like to be able to run it directly in the <code>nix</code> environment. We modify the script as follows:</p><pre><code><span>#! /usr/bin/env nix-shell\n</span><span></span><span>#! nix-shell deps.nix -i bash</span>\n\n<span># Build Doxygen</span>\n<span>cd</span> docs/Doxygen\ndoxygen Doxyfile-syme.cfg\n\n<span># Build Sphinx</span>\n<span>cd</span> ../Sphinx\nmake html\nmv build/html ../../public\n\n<span># Local Variables:</span>\n<span># mode: shell-script</span>\n<span># End:</span>\n</code></pre><p>This calls on a <code>deps.nix</code><a href=\"https://rgoswami.me/posts/pub-doc-cpp-dox-sph-nix/#fn:2\">2</a> which we shall generate in a manner very reminiscent of the <code>shell.nix</code> <a href=\"https://rgoswami.me/posts/pub-doc-cpp-dox-sph-nix/#fn:3\">3</a> as follows:</p><pre><code><span>let</span>\n  <span>sources</span> <span>=</span> <span>import</span> <span>./../nix/sources.nix</span><span>;</span>\n  <span>pkgs</span> <span>=</span> <span>import</span> <span>sources</span><span>.</span><span>nixpkgs</span> <span>{</span> <span>};</span>\n  <span>customPython</span> <span>=</span> <span>pkgs</span><span>.</span><span>poetry2nix</span><span>.</span><span>mkPoetryEnv</span> <span>{</span> <span>projectDir</span> <span>=</span> <span>./../.</span><span>;</span> <span>};</span>\n<span>in</span> <span>pkgs</span><span>.</span><span>runCommand</span> <span>\"dummy\"</span> <span>{</span>\n  <span>buildInputs</span> <span>=</span> <span>with</span> <span>pkgs</span><span>;</span> <span>[</span> <span>doxygen</span> <span>customPython</span> <span>];</span>\n<span>}</span> <span>\"\"</span>\n</code></pre><p>Only the paths have changed, and instead of creating and returning a shell environment with <code>mkShell</code> we instead “run” a derivation instead. At this point we can run this simply as:</p><pre><code>./scripts/build.sh\n</code></pre><p>This is reasonably ready (as a first draft) for being incorporated into a continuous integration workflow.</p><h2>Travis CI</h2><p>Seeing as Travis provides first class <code>nix</code> support, as well as excellent integration with GitHub, we will prefer it.</p><h3>Settings</h3><p>A minor but necessary evil is setting up a PAP (<a href=\"https://docs.github.com/apps/building-oauth-apps/scopes-for-oauth-apps/\">personal access token</a>) <a href=\"https://github.com/settings/tokens\">from here</a>. Depending on what repositories are being used, the scope should encompass <code>repo</code> permissions (minimally <code>public_repo</code>), and <code>admin:org</code> permissions might be required.</p><p>Having obtained the token, we will need to navigate to the Settings section on the Travis web-UI and add the token as an environment variable, we might be partial to a name like <code>GH_TOKEN</code>.</p><img src=\"https://d33wubrfki0l68.cloudfront.net/bd37e9e6495010cd1086801c9011ff5a2ae2e0bd/fd79f/ox-hugo/2020-09-22_09-55-21_screenshot.png\" alt=\"Figure 1: Settings at travis-ci.com/host/proj/settings\" /><p>Figure 1: Settings at <code>travis-ci.com/host/proj/settings</code></p><h3>Build Configuration</h3><p>We will leverage the following configuration:</p><pre><code><span>language</span><span>:</span><span> </span><span>nix</span><span>\n</span><span>\n</span><span></span><span>before_install</span><span>:</span><span>\n</span><span>  </span>- <span>sudo mkdir -p /etc/nix</span><span>\n</span><span>  </span>- <span>echo \"substituters = https://cache.nixos.org/ file://$HOME/nix.store\" | sudo tee -a /etc/nix/nix.conf &gt; /dev/null</span><span>\n</span><span>  </span>- <span>echo 'require-sigs = false' | sudo tee -a /etc/nix/nix.conf &gt; /dev/null</span><span>\n</span><span>\n</span><span></span><span>before_script</span><span>:</span><span>\n</span><span>  </span>- <span>sudo mkdir -p /etc/nix &amp;&amp; echo 'sandbox = true' | sudo tee /etc/nix/nix.conf</span><span>\n</span><span>\n</span><span></span><span>script</span><span>:</span><span>\n</span><span>  </span>- <span>scripts/build.sh</span><span>\n</span><span>\n</span><span></span><span>before_cache</span><span>:</span><span>\n</span><span>  </span>- <span>mkdir -p $HOME/nix.store</span><span>\n</span><span>  </span>- <span>nix copy --to file://$HOME/nix.store -f shell.nix buildInputs</span><span>\n</span><span>\n</span><span></span><span>cache</span><span>:</span><span>\n</span><span>  </span><span>nix</span><span>:</span><span> </span><span>true</span><span>\n</span><span>  </span><span>directories</span><span>:</span><span>\n</span><span>    </span>- <span>$HOME/nix.store</span><span>\n</span><span>\n</span><span></span><span>deploy</span><span>:</span><span>\n</span><span>  </span><span>provider</span><span>:</span><span> </span><span>pages</span><span>\n</span><span>  </span><span>local_dir</span><span>:</span><span> </span><span>./public/</span><span>\n</span><span>  </span><span>skip_cleanup</span><span>:</span><span> </span><span>true</span><span>\n</span><span>  </span><span>github_token</span><span>:</span><span> </span><span>$GH_TOKEN</span><span> </span><span># Set in the settings page of your repository, as a secure variable</span><span>\n</span><span>  </span><span>keep_history</span><span>:</span><span> </span><span>true</span><span>\n</span><span>  </span><span>target_branch</span><span>:</span><span> </span><span>master</span><span> </span><span># Required for user pages</span><span>\n</span><span>  </span><span>on</span><span>:</span><span>\n</span><span>    </span><span>branch</span><span>:</span><span> </span><span>src</span><span>\n</span></code></pre><p>Where all the action is essentially in <code>script</code> and <code>deploy</code>. Note however, that the <code>before_cache</code> step should change if there is a <code>default.nix</code> instead. We will in this case, consider the situation of having an organization or user page being the deploy target.</p><h2>Rake</h2><p>Usable though the preceding setting is, it is still rather unwieldy in that:</p><ul><li>there are a bunch of artifacts which need to be cleaned manually</li>\n<li>it is fragile and tied to the folder names</li>\n</ul><p>We can fix this with any of the popular build systems, however here we will focus on the excellent <code>rake</code> <a href=\"https://rgoswami.me/posts/pub-doc-cpp-dox-sph-nix/#fn:4\">4</a>. We shall commit to our course of action by removing <code>make</code>.</p><pre><code><span>cd</span> docs/Sphinx\nrm Makefile make.bat <span># other make cruft</span>\n</code></pre><h3>Components</h3><h4>Variables</h4><p>We will begin by requiring <code>rake</code> and setting basic variables.</p><pre><code><span>require</span> <span>'rake'</span>\n\n<span>CWD</span> <span>=</span> <span>File</span><span>.</span><span>expand_path</span><span>(</span><span>__dir__</span><span>)</span>\n<span>DOXYFILE</span> <span>=</span> <span>\"Doxyfile-prj.cfg\"</span>\n<span>OUTDIR</span> <span>=</span> <span>File</span><span>.</span><span>join</span><span>(</span><span>CWD</span><span>,</span><span>\"public\"</span><span>)</span>\n<span>SPHINXDIR</span> <span>=</span> <span>File</span><span>.</span><span>join</span><span>(</span><span>CWD</span><span>,</span><span>\"docs/Sphinx\"</span><span>)</span>\n</code></pre><p>This section should give a fairly clear idea of how the <code>Rakefile</code> itself is essentially pure <code>ruby</code> code. We are now beginning to have more holistic control of how our project is structured.</p><h3>Tasks</h3><p>The general form of a <code>task</code> is simply:</p><pre><code><span>desc</span> <span>\"Blah blah\"</span>\n<span>task</span> <span>:name</span> <span>do</span>\n<span># Something</span>\n<span>end</span>\n</code></pre><p>Some variations of this will be considered when appropriate.</p><h4>Clean</h4><p>A <code>clean</code> task is a good first task, being as it is almost trivial in all build systems.</p><pre><code><span>desc</span> <span>\"Clean the generated content\"</span>\n<span>task</span> <span>:clean</span> <span>do</span>\n  <span>rm_rf</span> <span>\"public\"</span>\n  <span>rm_rf</span> <span>\"docs/Doxygen/gen_docs\"</span>\n  <span>rm_rf</span> <span>\"docs/Sphinx/build\"</span>\n<span>end</span>\n</code></pre><h4>Serve</h4><p>We will use the <a href=\"https://wiki.alpinelinux.org/wiki/Darkhttpd\">lightweight darkhttpd server</a> for our generated documentation.</p><pre><code><span>desc</span> <span>\"Serve site with darkhttpd\"</span>\n<span>task</span> <span>:darkServe</span><span>,</span> <span>[</span><span>:port</span><span>]</span> <span>do</span> <span>|</span><span>task</span><span>,</span> <span>args</span><span>|</span>\n  <span>args</span><span>.</span><span>with_defaults</span><span>(</span><span>:port</span> <span>=&gt;</span> <span>\"1337\"</span><span>)</span>\n  <span>sh</span> <span>\"darkhttpd </span><span>#{</span><span>OUTDIR</span><span>}</span><span> --port </span><span>#{</span><span>args</span><span>.</span><span>port</span><span>}</span><span>\"</span>\n<span>end</span>\n</code></pre><p>Note that we have leveraged the <code>args</code> system in this case, and also used the top-level <code>OUTDIR</code> variable.</p><h4>Doxygen</h4><p>Since the <code>doxygen</code> output is a pre-requisite, it makes sense to set it up early on.</p><pre><code><span>desc</span> <span>\"Build doxygen\"</span>\n<span>task</span> <span>:mkDoxy</span> <span>do</span>\n  <span>Dir</span><span>.</span><span>chdir</span><span>(</span><span>to</span> <span>=</span> <span>File</span><span>.</span><span>join</span><span>(</span><span>CWD</span><span>,</span><span>\"docs/Doxygen\"</span><span>))</span>\n  <span>system</span><span>(</span><span>'doxygen'</span><span>,</span> <span>DOXYFILE</span><span>)</span>\n<span>end</span>\n</code></pre><h4>Sphinx</h4><p>This task will depend on having the <code>doxygen</code> output, so we will express this idiomatically by making the <code>doxygen</code> task run early on.</p><pre><code><span>desc</span> <span>\"Build Sphinx\"</span>\n<span>task</span> <span>:mkSphinx</span><span>,</span> <span>[</span><span>:builder</span><span>]</span> <span>=&gt;</span> <span>[</span><span>\"mkDoxy\"</span><span>]</span> <span>do</span> <span>|</span><span>task</span><span>,</span> <span>args</span><span>|</span>\n  <span>args</span><span>.</span><span>with_defaults</span><span>(</span><span>:builder</span> <span>=&gt;</span> <span>\"html\"</span><span>)</span>\n  <span>Dir</span><span>.</span><span>chdir</span><span>(</span><span>to</span> <span>=</span> <span>File</span><span>.</span><span>join</span><span>(</span><span>CWD</span><span>,</span><span>\"docs/Sphinx\"</span><span>))</span>\n  <span>sh</span> <span>\"poetry install\"</span>\n  <span>sh</span> <span>\"poetry run sphinx-build source </span><span>#{</span><span>OUTDIR</span><span>}</span><span> -b </span><span>#{</span><span>args</span><span>.</span><span>builder</span><span>}</span><span>\"</span>\n<span>end</span>\n</code></pre><p>There are some subtleties here, notably:</p><ul><li>The task is meant to run <strong>without</strong> <code>nix</code>\n</li>\n<li>We use the <code>args</code> setup as before</li>\n</ul><h4>No Nix Meta</h4><p>With this we can now set up a task to build the documentation without having <code>nix</code>.</p><pre><code><span>desc</span> <span>\"Build site without Nix\"</span>\n<span>task</span> <span>:noNixBuild</span> <span>=&gt;</span> <span>\"mkSphinx\"</span> <span>do</span>\n  <span>Rake</span><span>::</span><span>Task</span><span>[</span><span>\"darkServe\"</span><span>].</span><span>execute</span>\n<span>end</span>\n</code></pre><p>The main take-away here is that we finally call the <code>Rake</code> library itself, but within the task, which means the dependency tree is respected and we get <code>doxygen-&gt;sphinx-&gt;darkhttpd</code> as required.</p><h4>Nix Builder</h4><p>For <code>nix</code> use we note that we are unable to enter the <code>nix</code> environment from within the <code>Rakefile</code> itself. We work around this by being more descriptive.</p><pre><code><span>desc</span> <span>\"Build Nix Sphinx, use as nix-shell --run 'rake mkNixDoc' --pure\"</span>\n<span>task</span> <span>:mkNixDoc</span><span>,</span> <span>[</span><span>:builder</span><span>]</span> <span>=&gt;</span> <span>\"mkDoxy\"</span> <span>do</span> <span>|</span><span>task</span><span>,</span> <span>args</span><span>|</span>\n  <span>args</span><span>.</span><span>with_defaults</span><span>(</span><span>:builder</span> <span>=&gt;</span> <span>\"html\"</span><span>)</span>\n  <span>Dir</span><span>.</span><span>chdir</span><span>(</span><span>to</span> <span>=</span> <span>SPHINXDIR</span><span>)</span>\n  <span>sh</span> <span>\"sphinx-build source </span><span>#{</span><span>OUTDIR</span><span>}</span><span> -b </span><span>#{</span><span>args</span><span>.</span><span>builder</span><span>}</span><span>\"</span>\n<span>end</span>\n</code></pre><h3>Final Form</h3><p>The final <code>Rakefile</code> shall be (with a default task defined):</p><pre><code><span>require</span> <span>'rake'</span>\n\n<span># Variables</span>\n<span>CWD</span> <span>=</span> <span>File</span><span>.</span><span>expand_path</span><span>(</span><span>__dir__</span><span>)</span>\n<span>DOXYFILE</span> <span>=</span> <span>\"Doxyfile-prj.cfg\"</span>\n<span>OUTDIR</span> <span>=</span> <span>File</span><span>.</span><span>join</span><span>(</span><span>CWD</span><span>,</span><span>\"public\"</span><span>)</span>\n<span>SPHINXDIR</span> <span>=</span> <span>File</span><span>.</span><span>join</span><span>(</span><span>CWD</span><span>,</span><span>\"docs/Sphinx\"</span><span>)</span>\n\n<span># Tasks</span>\n<span>task</span> <span>:default</span> <span>=&gt;</span> <span>:darkServe</span>\n\n<span>desc</span> <span>\"Clean the generated content\"</span>\n<span>task</span> <span>:clean</span> <span>do</span>\n  <span>rm_rf</span> <span>\"public\"</span>\n  <span>rm_rf</span> <span>\"docs/Doxygen/gen_docs\"</span>\n  <span>rm_rf</span> <span>\"docs/Sphinx/build\"</span>\n<span>end</span>\n\n<span>desc</span> <span>\"Serve site with darkhttpd\"</span>\n<span>task</span> <span>:darkServe</span><span>,</span> <span>[</span><span>:port</span><span>]</span> <span>do</span> <span>|</span><span>task</span><span>,</span> <span>args</span><span>|</span>\n  <span>args</span><span>.</span><span>with_defaults</span><span>(</span><span>:port</span> <span>=&gt;</span> <span>\"1337\"</span><span>)</span>\n  <span>sh</span> <span>\"darkhttpd </span><span>#{</span><span>OUTDIR</span><span>}</span><span> --port </span><span>#{</span><span>args</span><span>.</span><span>port</span><span>}</span><span>\"</span>\n<span>end</span>\n\n<span>desc</span> <span>\"Build Nix Sphinx, use as nix-shell --run 'rake mkNixDoc' --pure\"</span>\n<span>task</span> <span>:mkNixDoc</span><span>,</span> <span>[</span><span>:builder</span><span>]</span> <span>=&gt;</span> <span>\"mkDoxy\"</span> <span>do</span> <span>|</span><span>task</span><span>,</span> <span>args</span><span>|</span>\n  <span>args</span><span>.</span><span>with_defaults</span><span>(</span><span>:builder</span> <span>=&gt;</span> <span>\"html\"</span><span>)</span>\n  <span>Dir</span><span>.</span><span>chdir</span><span>(</span><span>to</span> <span>=</span> <span>SPHINXDIR</span><span>)</span>\n  <span>sh</span> <span>\"sphinx-build source </span><span>#{</span><span>OUTDIR</span><span>}</span><span> -b </span><span>#{</span><span>args</span><span>.</span><span>builder</span><span>}</span><span>\"</span>\n<span>end</span>\n\n<span>desc</span> <span>\"Build site without Nix\"</span>\n<span>task</span> <span>:noNixBuild</span> <span>=&gt;</span> <span>\"mkSphinx\"</span> <span>do</span>\n  <span>Rake</span><span>::</span><span>Task</span><span>[</span><span>\"darkServe\"</span><span>].</span><span>execute</span>\n<span>end</span>\n\n<span>desc</span> <span>\"Build doxygen\"</span>\n<span>task</span> <span>:mkDoxy</span> <span>do</span>\n  <span>Dir</span><span>.</span><span>chdir</span><span>(</span><span>to</span> <span>=</span> <span>File</span><span>.</span><span>join</span><span>(</span><span>CWD</span><span>,</span><span>\"docs/Doxygen\"</span><span>))</span>\n  <span>system</span><span>(</span><span>'doxygen'</span><span>,</span> <span>DOXYFILE</span><span>)</span>\n<span>end</span>\n\n<span>desc</span> <span>\"Build Sphinx\"</span>\n<span>task</span> <span>:mkSphinx</span><span>,</span> <span>[</span><span>:builder</span><span>]</span> <span>=&gt;</span> <span>[</span><span>\"mkDoxyRest\"</span><span>]</span> <span>do</span> <span>|</span><span>task</span><span>,</span> <span>args</span><span>|</span>\n  <span>args</span><span>.</span><span>with_defaults</span><span>(</span><span>:builder</span> <span>=&gt;</span> <span>\"html\"</span><span>)</span>\n  <span>Dir</span><span>.</span><span>chdir</span><span>(</span><span>to</span> <span>=</span> <span>File</span><span>.</span><span>join</span><span>(</span><span>CWD</span><span>,</span><span>\"docs/Sphinx\"</span><span>))</span>\n  <span>sh</span> <span>\"poetry install\"</span>\n  <span>sh</span> <span>\"poetry run sphinx-build source </span><span>#{</span><span>OUTDIR</span><span>}</span><span> -b </span><span>#{</span><span>args</span><span>.</span><span>builder</span><span>}</span><span>\"</span>\n<span>end</span>\n</code></pre><h3>Travis</h3><p>We are now in a position to fix our <code>travis</code> build configuration. Simply replace the old and fragile <code>build.sh</code> script section with the following:</p><pre><code><span>script</span><span>:</span><span>\n</span><span>  </span>- <span>nix-shell --run \"rake mkNixDoc\" --show-trace --verbose --pure</span><span>\n</span></code></pre><h3>Direnv</h3><p>As a bonus section, consider the addition of the following <code>.envrc</code> for those who keep multiple <code>ruby</code> versions:</p><pre><code><span>eval</span> <span>\"</span><span>$(</span>rbenv init -<span>)</span><span>\"</span>\nrbenv shell 2.6.2\nrake -T\n</code></pre><p>Activate this with the usual <code>direnv allow</code>. This has the added benefit of listing the defined tasks when <code>cd</code>‘ing into the project directory.</p><h2>Conclusions</h2><p>A lot has happened on the tooling end, even though the documentation itself has not been updated further. We have managed to setup a robust environment which is both reproducible and also amenable to users who do not have <code>nix</code>. We have also setup a build system, which can help us in many more ways as well (asset optimization through the <code>rails</code> pipeline). In the next post, we will return to the documentation itself for further tinkering.</p><ol><li><p><a href=\"https://python-poetry.org/\">Poetry</a> and <a href=\"https://pipenv-fork.readthedocs.io/\">Pipenv</a> come to mind <a href=\"https://rgoswami.me/posts/pub-doc-cpp-dox-sph-nix/#fnref:1\">↩︎</a></p></li>\n<li><p>Chris Warbo has a good <a href=\"http://chriswarbo.net/projects/nixos/nix_shell_shebangs.html\">introduction to the nix shebang</a> <a href=\"https://rgoswami.me/posts/pub-doc-cpp-dox-sph-nix/#fnref:2\">↩︎</a></p></li>\n<li><p>In this instance, we could have simply called on <code>shell.nix</code> instead, but it illustrates a more general concept <a href=\"https://rgoswami.me/posts/pub-doc-cpp-dox-sph-nix/#fnref:3\">↩︎</a></p></li>\n<li><p><a href=\"https://avdi.codes/tag/rake/page/2/\">Avdi’s blog has a fantastic introduction</a> to <code>rake</code> and <code>Rakefiles</code> <a href=\"https://rgoswami.me/posts/pub-doc-cpp-dox-sph-nix/#fnref:4\">↩︎</a></p></li>\n</ol>",
      "text": "Automating documenation deployment with Travis, rake and nixBackgroundIn the previous post we generated documentation using Doxygen with Exhale to handle Sphinx. Now we will clean up the earlier workflow with rake and ensure the environment is reproducible with nix while deploying to Travis CI.SeriesDocumenting C++ with Doxygen and Sphinx - Exhale\n\nPublishing Doxygen and Sphinx with Nix and Rake <– You are here\nDocumenting C++ with Doxygen and Sphinx - doxyrest\nAdding Tutorials to Sphinx Projects\nSetupA quick reminder of the setup we generated in the last post:tree -d $prj/ -L 2\n.\n\n\n├──\ndocs\n\n│  \n├──\nDoxygen\n│  \n└──\nSphinx\n├──\nnix\n\n│  \n└──\npkgs\n├──\nprojects\n\n│  \n└──\nsymengine\n└──\nscripts\n\n\n\n\n8\ndirectories\n\nWe had further setup files to enable documentation generation with a manual two stage process (handling doxygen and sphinx separately).cd docs/Doxygen\ndoxygen Doxyfile-prj.cfg\ncd ../Sphinx\nmake html\nmv build/html ../../public\nThis might be extracted into a simple build.sh script, and then we might decide to have a clean.sh script and then we might try to replicate all the functionality of a good build system with scripts.Thankfully, we will instead start with a build script defined as above to transition to nix, before using an actual build tool for our dirty work.Adding NixIt wouldn’t make sense for me to not stick nix into this. I recall the dark days of setting up Dockerfiles to ensure reproducible environments on Travis.At this point one might assume we will leverage the requirements.txt based workflow described earlier in Niv and Mach-Nix for Nix Python. While this would make sense, there are two barriers to its usage:It is slower than a poetry build, as dependency resolution is performed\nIt does not play well with existing projectsMost python projects do not rely solely on requirements.txt 1\nPoetry2NixRecall that as sphinx is originally meant for and most often used for Python projects, we will need to consider the possibility (remote though it is) that there might be users who would like to test the documentation without setting up nix.Thus we will look to the poetry2nix project instead. We note the following:The poetry2nix setup is faster (as it consumes a lockfile instead of solving dependencies from requirements.txt)\nmach-nix however, is more flexible and can make use of the poetry2nix overrides\nIn a strange chicken and egg problem, we will have to manually generate the lockfile, thereby creating an impure poetry project for every update, though the nix setup will not need it laterThis is one of the major reasons to prefer mach-nix for newer projects\nShell EnvironmentWe prep our sources in the usual way, by running niv init in the project root to generate the nix/ folder and the sources therein. With all that in mind, the shell.nix file at this point is fairly standard, keeping the general niv setup in mind (described in a previous Nix tutorial):# -*- mode: nix-mode -*-\nlet\n  sources = import ./nix/sources.nix;\n  pkgs = import sources.nixpkgs { };\n  customPython = pkgs.poetry2nix.mkPoetryEnv { projectDir = ./.; };\nin pkgs.mkShell {\n  buildInputs = with pkgs; [ doxygen customPython rake darkhttpd ];\n}\nWhere the most interesting aspect is that the projectDir is to be the location of the project root, though both poetrylock and pyproject variables are supported.RefactoringWe consider the problem of refactoring the build.sh script:#!/usr/bin/env bash\ncd docs/Doxygen\ndoxygen Doxyfile-prj.cfg\ncd ../Sphinx\nmake html\nmv build/html ../../public\nWithout resorting to methods such as nix-shell --run build.sh --pure.Nix BashScript in hand, we would like to be able to run it directly in the nix environment. We modify the script as follows:#! /usr/bin/env nix-shell\n#! nix-shell deps.nix -i bash\n\n# Build Doxygen\ncd docs/Doxygen\ndoxygen Doxyfile-syme.cfg\n\n# Build Sphinx\ncd ../Sphinx\nmake html\nmv build/html ../../public\n\n# Local Variables:\n# mode: shell-script\n# End:\nThis calls on a deps.nix2 which we shall generate in a manner very reminiscent of the shell.nix 3 as follows:let\n  sources = import ./../nix/sources.nix;\n  pkgs = import sources.nixpkgs { };\n  customPython = pkgs.poetry2nix.mkPoetryEnv { projectDir = ./../.; };\nin pkgs.runCommand \"dummy\" {\n  buildInputs = with pkgs; [ doxygen customPython ];\n} \"\"\nOnly the paths have changed, and instead of creating and returning a shell environment with mkShell we instead “run” a derivation instead. At this point we can run this simply as:./scripts/build.sh\nThis is reasonably ready (as a first draft) for being incorporated into a continuous integration workflow.Travis CISeeing as Travis provides first class nix support, as well as excellent integration with GitHub, we will prefer it.SettingsA minor but necessary evil is setting up a PAP (personal access token) from here. Depending on what repositories are being used, the scope should encompass repo permissions (minimally public_repo), and admin:org permissions might be required.Having obtained the token, we will need to navigate to the Settings section on the Travis web-UI and add the token as an environment variable, we might be partial to a name like GH_TOKEN.Figure 1: Settings at travis-ci.com/host/proj/settingsBuild ConfigurationWe will leverage the following configuration:language: nix\n\nbefore_install:\n  - sudo mkdir -p /etc/nix\n  - echo \"substituters = https://cache.nixos.org/ file://$HOME/nix.store\" | sudo tee -a /etc/nix/nix.conf > /dev/null\n  - echo 'require-sigs = false' | sudo tee -a /etc/nix/nix.conf > /dev/null\n\nbefore_script:\n  - sudo mkdir -p /etc/nix && echo 'sandbox = true' | sudo tee /etc/nix/nix.conf\n\nscript:\n  - scripts/build.sh\n\nbefore_cache:\n  - mkdir -p $HOME/nix.store\n  - nix copy --to file://$HOME/nix.store -f shell.nix buildInputs\n\ncache:\n  nix: true\n  directories:\n    - $HOME/nix.store\n\ndeploy:\n  provider: pages\n  local_dir: ./public/\n  skip_cleanup: true\n  github_token: $GH_TOKEN # Set in the settings page of your repository, as a secure variable\n  keep_history: true\n  target_branch: master # Required for user pages\n  on:\n    branch: src\nWhere all the action is essentially in script and deploy. Note however, that the before_cache step should change if there is a default.nix instead. We will in this case, consider the situation of having an organization or user page being the deploy target.RakeUsable though the preceding setting is, it is still rather unwieldy in that:there are a bunch of artifacts which need to be cleaned manually\nit is fragile and tied to the folder names\nWe can fix this with any of the popular build systems, however here we will focus on the excellent rake 4. We shall commit to our course of action by removing make.cd docs/Sphinx\nrm Makefile make.bat # other make cruft\nComponentsVariablesWe will begin by requiring rake and setting basic variables.require 'rake'\n\nCWD = File.expand_path(__dir__)\nDOXYFILE = \"Doxyfile-prj.cfg\"\nOUTDIR = File.join(CWD,\"public\")\nSPHINXDIR = File.join(CWD,\"docs/Sphinx\")\nThis section should give a fairly clear idea of how the Rakefile itself is essentially pure ruby code. We are now beginning to have more holistic control of how our project is structured.TasksThe general form of a task is simply:desc \"Blah blah\"\ntask :name do\n# Something\nend\nSome variations of this will be considered when appropriate.CleanA clean task is a good first task, being as it is almost trivial in all build systems.desc \"Clean the generated content\"\ntask :clean do\n  rm_rf \"public\"\n  rm_rf \"docs/Doxygen/gen_docs\"\n  rm_rf \"docs/Sphinx/build\"\nend\nServeWe will use the lightweight darkhttpd server for our generated documentation.desc \"Serve site with darkhttpd\"\ntask :darkServe, [:port] do |task, args|\n  args.with_defaults(:port => \"1337\")\n  sh \"darkhttpd #{OUTDIR} --port #{args.port}\"\nend\nNote that we have leveraged the args system in this case, and also used the top-level OUTDIR variable.DoxygenSince the doxygen output is a pre-requisite, it makes sense to set it up early on.desc \"Build doxygen\"\ntask :mkDoxy do\n  Dir.chdir(to = File.join(CWD,\"docs/Doxygen\"))\n  system('doxygen', DOXYFILE)\nend\nSphinxThis task will depend on having the doxygen output, so we will express this idiomatically by making the doxygen task run early on.desc \"Build Sphinx\"\ntask :mkSphinx, [:builder] => [\"mkDoxy\"] do |task, args|\n  args.with_defaults(:builder => \"html\")\n  Dir.chdir(to = File.join(CWD,\"docs/Sphinx\"))\n  sh \"poetry install\"\n  sh \"poetry run sphinx-build source #{OUTDIR} -b #{args.builder}\"\nend\nThere are some subtleties here, notably:The task is meant to run without nix\n\nWe use the args setup as before\nNo Nix MetaWith this we can now set up a task to build the documentation without having nix.desc \"Build site without Nix\"\ntask :noNixBuild => \"mkSphinx\" do\n  Rake::Task[\"darkServe\"].execute\nend\nThe main take-away here is that we finally call the Rake library itself, but within the task, which means the dependency tree is respected and we get doxygen->sphinx->darkhttpd as required.Nix BuilderFor nix use we note that we are unable to enter the nix environment from within the Rakefile itself. We work around this by being more descriptive.desc \"Build Nix Sphinx, use as nix-shell --run 'rake mkNixDoc' --pure\"\ntask :mkNixDoc, [:builder] => \"mkDoxy\" do |task, args|\n  args.with_defaults(:builder => \"html\")\n  Dir.chdir(to = SPHINXDIR)\n  sh \"sphinx-build source #{OUTDIR} -b #{args.builder}\"\nend\nFinal FormThe final Rakefile shall be (with a default task defined):require 'rake'\n\n# Variables\nCWD = File.expand_path(__dir__)\nDOXYFILE = \"Doxyfile-prj.cfg\"\nOUTDIR = File.join(CWD,\"public\")\nSPHINXDIR = File.join(CWD,\"docs/Sphinx\")\n\n# Tasks\ntask :default => :darkServe\n\ndesc \"Clean the generated content\"\ntask :clean do\n  rm_rf \"public\"\n  rm_rf \"docs/Doxygen/gen_docs\"\n  rm_rf \"docs/Sphinx/build\"\nend\n\ndesc \"Serve site with darkhttpd\"\ntask :darkServe, [:port] do |task, args|\n  args.with_defaults(:port => \"1337\")\n  sh \"darkhttpd #{OUTDIR} --port #{args.port}\"\nend\n\ndesc \"Build Nix Sphinx, use as nix-shell --run 'rake mkNixDoc' --pure\"\ntask :mkNixDoc, [:builder] => \"mkDoxy\" do |task, args|\n  args.with_defaults(:builder => \"html\")\n  Dir.chdir(to = SPHINXDIR)\n  sh \"sphinx-build source #{OUTDIR} -b #{args.builder}\"\nend\n\ndesc \"Build site without Nix\"\ntask :noNixBuild => \"mkSphinx\" do\n  Rake::Task[\"darkServe\"].execute\nend\n\ndesc \"Build doxygen\"\ntask :mkDoxy do\n  Dir.chdir(to = File.join(CWD,\"docs/Doxygen\"))\n  system('doxygen', DOXYFILE)\nend\n\ndesc \"Build Sphinx\"\ntask :mkSphinx, [:builder] => [\"mkDoxyRest\"] do |task, args|\n  args.with_defaults(:builder => \"html\")\n  Dir.chdir(to = File.join(CWD,\"docs/Sphinx\"))\n  sh \"poetry install\"\n  sh \"poetry run sphinx-build source #{OUTDIR} -b #{args.builder}\"\nend\nTravisWe are now in a position to fix our travis build configuration. Simply replace the old and fragile build.sh script section with the following:script:\n  - nix-shell --run \"rake mkNixDoc\" --show-trace --verbose --pure\nDirenvAs a bonus section, consider the addition of the following .envrc for those who keep multiple ruby versions:eval \"$(rbenv init -)\"\nrbenv shell 2.6.2\nrake -T\nActivate this with the usual direnv allow. This has the added benefit of listing the defined tasks when cd‘ing into the project directory.ConclusionsA lot has happened on the tooling end, even though the documentation itself has not been updated further. We have managed to setup a robust environment which is both reproducible and also amenable to users who do not have nix. We have also setup a build system, which can help us in many more ways as well (asset optimization through the rails pipeline). In the next post, we will return to the documentation itself for further tinkering.Poetry and Pipenv come to mind ↩︎\nChris Warbo has a good introduction to the nix shebang ↩︎\nIn this instance, we could have simply called on shell.nix instead, but it illustrates a more general concept ↩︎\nAvdi’s blog has a fantastic introduction to rake and Rakefiles ↩︎"
    },
    "mention-of": "https://rgoswami.me/posts/doc-cpp-dox-sph-exhale/",
    "wm-property": "mention-of",
    "wm-private": false,
    "rels": {
      "canonical": "https://rgoswami.me/posts/pub-doc-cpp-dox-sph-nix/"
    }
  }
]
